import tap


class GapArgs(tap.Tap):
    ntrials: int = 5
    niters: int = 1


class RedisArgs(tap.Tap):
    from .config import YcsbWorkload

    workload: YcsbWorkload = YcsbWorkload.A


class ManualArgs(tap.Tap):
    cmd: str = ""


class Bench:
    NAME = "bench"
    MANUAL = "manual"
    REDIS = "redis"
    GAP = "gap"


class Args(tap.Tap):
    from .config import LogLevel, VCPUBind

    num: int  # How many VMs to launch
    ncpus: int = 4  # How many vCPUs for each VM
    bind: VCPUBind = VCPUBind.CORE  # Bind guest CPU to certain host node or vCPU
    memory: int = 8 << 30  # How memory in byte for each VM
    dram_ratio: float = 0.2  # Initial DRAM ratio out of all system-ram
    log_level: LogLevel = LogLevel.INFO  # Logging level, defaults to info
    perf_event: str = ""  # Enable perf events collection in guests
    memory_mode: bool = False  # Enable memory mode
    pretty: bool = False  # Enable pretty printing using rich

    def configure(self) -> None:
        # bench: Bench = Bench.MANUAL  # Benchmark to run
        self.add_subparsers(dest=Bench.NAME, help="Which benchmark to run")
        self.add_subparser(Bench.MANUAL, ManualArgs)
        self.add_subparser(Bench.REDIS, RedisArgs)
        self.add_subparser(Bench.GAP, GapArgs)


def main(args: Args):
    from logging import info

    from .benchmark.redis import redis
    from .benchmark.gap import gap_bc
    from .config import host_cpu_cycler
    from .utils import log
    from .vm import Vm, insmod, launch_vms, numa_balancing

    # https://stackoverflow.com/a/44401529
    log(args.log_level, args.pretty)
    info(args)
    with launch_vms(
        args.num,
        ncpus=args.ncpus,
        memory=args.memory,
        dram_ratio=args.dram_ratio,
        memory_mode=args.memory_mode,
        vcpubind=args.bind,
        cpu_cycler=host_cpu_cycler(),
    ) as vms:
        info("all vm started")
        insmod(vms)
        numa_balancing(vms, False)
        match getattr(args, Bench.NAME):
            case Bench.MANUAL:
                info("wait for manual termination via pkill cloud-hyperviso")
                list(map(Vm.wait, vms))
            case Bench.REDIS:
                info("benchmark to run: redis")
                redis(vms, args.workload, args.ncpus, args.memory_mode, args.perf_event)
                info("benchmark finished: redis")
            case Bench.GAP:
                info("benchmark to run: gap_bc")
                gap_bc(vms, args.ntrials, args.niters)
                info("benchmark finished: gap_bc")
            case _:
                assert False, "Unreachable"


# # credit: https://stackoverflow.com/a/70124136 https://stackoverflow.com/a/60750535
# class EnumAction(argparse.Action):
#     """
#     Argparse action for handling Enums
#     """

#     def __init__(self, **kwargs):
#         # Pop off the type value
#         enum_type = kwargs.pop("type", None)

#         # Ensure an Enum subclass is provided
#         if enum_type is None:
#             raise ValueError("type must be assigned an Enum when using EnumAction")
#         if not issubclass(enum_type, enum.Enum):
#             raise TypeError("type must be an Enum when using EnumAction")

#         # Generate choices from the Enum
#         kwargs.setdefault("choices", tuple(e.name for e in enum_type))

#         super(EnumAction, self).__init__(**kwargs)

#         self._enum = enum_type

#     def __call__(
#         self,
#         parser: argparse.ArgumentParser,
#         namespace: argparse.Namespace,
#         value: Any,
#         option_string: str = None,
#     ):
#         # Convert value back into an Enum
#         if isinstance(value, str):
#             value = self._enum[value]
#             setattr(namespace, self.dest, value)
#         elif value is None:
#             raise argparse.ArgumentTypeError(
#                 f"You need to pass a value after {option_string}!"
#             )
#         else:
#             # A pretty invalid choice message will be generated by argparse
#             raise argparse.ArgumentTypeError()


# @classopt(default_long=True)
# class Opt:
#     """Command line arguements, usage: `opt = Opt.from_args()`"""

#     num: int = c(help="How many VMs to launch")
#     ncpus: int = c(default=4, help="How many vCPUs for each VM")
#     bind: VCPUBind = c(
#         type=VCPUBind,
#         default=VCPUBind.CORE,
#         action=EnumAction,
#         help="Bind guest CPU to certain host node or vCPU",
#     )
#     memory: int = c(default=8 << 30, help="How memory in byte for each VM")
#     dram_ratio: float = c(default=0.2, help="Initial DRAM ratio out of all system-ram")
#     log_level: LogLevel = c(
#         default=LogLevel.INFO,
#         type=LogLevel,
#         action=EnumAction,
#         help="Logging level, defaults to info",
#     )
#     perf: str = c(help="Enable perf events collection in guests")
#     memory_mode: bool = c(help="Enable memory mode")
#     bench: Benchmark = c(
#         default=Benchmark.MANUAL,
#         type=Benchmark,
#         action=EnumAction,
#         help="Benchmark to run",
#     )
#     workload: YcsbWorkload = c(
#         default=YcsbWorkload.A,
#         type=YcsbWorkload,
#         action=EnumAction,
#         help="Which ycsb workload to run on redis",
#     )
#     pretty: bool = c(help="Enable pretty printing using rich")
